# include "check_path.hpp"
#include "../parsing/location.hpp"

Check_path::Check_path(std::list<Client *>::iterator iter, Server &serv): skip(0)
{
    check_transfer_encoding(iter, serv);
}

void   Check_path::check_transfer_encoding(std::list<Client *>::iterator iter, Server &serv)
{
    // (*iter)->path, (*iter)->request_pack, (*iter)->content_type,
    std::map<std::string, std::vector<std::string> > map_req = (*iter)->request_pack;
    std::map<std::string, std::vector<std::string> >::iterator m_ap = map_req.find("Transfer-Encoding");
    if (m_ap != map_req.end())
    {
        std::vector<std::string> vec = m_ap->second;
        std::vector<std::string>::iterator itt = vec.begin();
        if (itt == vec.end())
        {
            std::cout<< "Transfer-Encoding with empty value error /501 not implemented"<<std::endl;
            // drop_client(iter);
            this->skip = 1;
            return ;
        }
        else
        {
            for(; itt != vec.end(); itt++)
            {
                if ((*itt) != "chunked")
                {
                    std::cout<< "Transfer-Encoding not a match error /501 not implemented"<<std::endl;
                    // drop_client(iter);
                    std::cout<<"heeeer"<<std::endl;
                    this->skip = 1;
                    return ;
                }
                else
                {
                    if ((*iter)->content_type == 1)
                    {
                        std::cout<<"Transfer-Encoding(chunked) and boundry error not implemented"<<std::endl;
                        //set_error page of not implemented
                        this->skip = 1;
                        return ;
                    }
                    else
                        (*iter)->content_type = 2;
                }
            }
        }
    }
    if (((*iter)->content_type == 0 || (*iter)->content_type == 1) && ((*iter)->method == "POST"))
    {
        std::map<std::string, std::vector<std::string> > map_req = (*iter)->request_pack;
        std::map<std::string, std::vector<std::string> >::iterator m_ap = map_req.find("Content-Length");
        if (m_ap != map_req.end())
        {
            std::vector<std::string> vec = m_ap->second;
            std::vector<std::string>::iterator itt = vec.begin();
            if (itt == vec.end())
            {
                std::cout<< "Content-Length exist with no value error /400 bad request"<<std::endl;
                // drop_client(iter);
                this->skip = 1;
                return ;
            }
            else
            {
                std::cout<<"con-len : "<<*itt<<std::endl;
            }
        }
        else
        {
            std::cout<< "Content-Length not exist error /400 bad request"<<std::endl;
            // drop_client(iter);
            this->skip = 1;
            return ;
        }
    }
    check_uri(iter, serv);
}

bool isCharAllowed(char c) {
    // List of allowed characters
    const std::string allowedChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~:/?#[]@!$&'()*+,;=%";
    
    // Check if the character is in the allowed list
    return (allowedChars.find(c) != std::string::npos);
}

bool isURIValid(const std::string& uri, int len) {
    // Check each character in the URI
    for (int i = 0; i < len; i++) {
        if (!isCharAllowed(uri[i])) {
            // Character not allowed, URI is invalid
            return false;
        }
    }
    
    // All characters are allowed, URI is valid
    return true;
}

void    Check_path::check_uri(std::list<Client *>::iterator iter, Server &serv)
{
    std::string uri = (*iter)->path;
    int len = uri.length();
    if (len > 2048)
    {
        std::cout<<"request-URI- too long error /414"<<std::endl;
        // drop-client;
        this->skip = 1;
        return ;
    }
    if (!isURIValid(uri, len)) {
        std::cout << "URI have invalid characters error /400 bad request" << std::endl;
        // drop-client;
        this->skip = 1;
        return ;
    }
    get_matched_location_for